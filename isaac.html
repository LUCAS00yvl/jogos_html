<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Isaac Blocks: Roguelike Edition</title>
    <style>
        :root { --bg: #0a0a0a; --paper: #dcd0b8; --ink: #2b2b2b; --accent: #ff4d4d; }
        body { 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            height: 100vh; margin: 0; background-color: #000; color: #eee; 
            font-family: 'Courier New', Courier, monospace; overflow: hidden; touch-action: none;
            user-select: none;
        }
        
        #menu {
            position: absolute; inset: 0; background: #050505;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000;
        }
        #menu h1 { font-size: 36px; color: #fff; text-shadow: 2px 2px #555; margin-bottom: 20px; letter-spacing: 2px; }
        .controls-info { color: #888; font-size: 14px; margin-bottom: 20px; text-align: center; line-height: 1.5; }
        
        .char-selector { display: flex; align-items: center; gap: 20px; }
        .nav-btn { background: none; border: none; color: #555; font-size: 50px; cursor: pointer; transition: 0.2s; }
        .nav-btn:hover { color: #fff; }
        .nav-btn:active { transform: scale(0.9); }

        .paper-card {
            background: var(--paper); color: var(--ink); width: 220px; height: 320px; padding: 20px;
            border-radius: 2px; box-shadow: 0 0 20px rgba(0,0,0,0.8), inset 0 0 50px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; align-items: center; position: relative; transform: rotate(-2deg);
        }
        
        .avatar-display { width: 80px; height: 80px; border-radius: 50%; border: 4px solid #000; margin-top: 10px; box-shadow: 5px 5px 0 rgba(0,0,0,0.2); }
        .paper-card h2 { margin: 15px 0 10px; font-size: 28px; border-bottom: 2px dashed #000; width: 100%; text-align: center; }
        .stats-display { text-align: left; width: 100%; font-weight: bold; font-size: 14px; line-height: 1.6; }
        .hearts { color: var(--accent); }

        #start-btn {
            margin-top: 30px; background: transparent; border: 3px solid #fff; color: #fff;
            padding: 10px 40px; font-size: 24px; font-family: 'Courier New', Courier, monospace;
            font-weight: bold; cursor: pointer; transition: 0.2s;
        }
        #start-btn:hover { background: #fff; color: #000; }

        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 100; }
        #item-banner {
            position: absolute; top: -150px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: #fff; border: 4px solid #444; padding: 15px 50px;
            text-align: center; transition: top 0.6s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            border-radius: 10px; box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }
        #item-banner.show { top: 50px; }

        canvas { 
            border: 4px solid #222; background: #000; 
            max-width: 95vw; max-height: 80vh; 
            image-rendering: pixelated; border-radius: 8px; cursor: crosshair;
        }

        .controls {
            position: absolute; bottom: 20px; width: 100%; height: 140px;
            display: flex; justify-content: space-between; padding: 0 30px; box-sizing: border-box;
            z-index: 500; opacity: 0.6;
        }
        .joy-base { width: 100px; height: 100px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; position: relative; }
        .joy-knob { width: 40px; height: 40px; background: #aaa; border-radius: 50%; position: absolute; left: 30px; top: 30px; pointer-events: none; }
        
        .hidden { display: none !important; }
        @media (min-width: 1024px) { .controls { display: none; } }
    </style>
</head>
<body oncontextmenu="return false;">

    <div id="menu">
        <h1>WHO AM I?</h1>
        <div class="controls-info">
            PC: WASD (Mover) | MOUSE (Mirar e Atirar) | SETAS (Opcional)<br>
            MOBILE: Use os Joysticks Virtuais na tela.
        </div>
        <div class="char-selector">
            <button class="nav-btn" onclick="changeChar(-1)">&#9664;</button>
            <div class="paper-card">
                <div id="m-avatar" class="avatar-display" style="background:#ffccb3;"></div>
                <h2 id="m-name">ISAAC</h2>
                <div class="stats-display">
                    HP: <span id="m-hp" class="hearts">♥♥♥</span><br>
                    DMG: <span id="m-dmg">3.5</span><br>
                    SPD: <span id="m-spd">4.0</span><br>
                    TEARS: <span id="m-trs">10</span><br>
                    RNG: <span id="m-rng">23.7</span>
                </div>
            </div>
            <button class="nav-btn" onclick="changeChar(1)">&#9654;</button>
        </div>
        <button id="start-btn" onclick="startGame()">SPACE TO START</button>
    </div>

    <div id="ui-layer" class="hidden">
        <div id="item-banner">
            <h2 id="it-name" style="margin:0; font-size: 24px;">ITEM!</h2>
            <p id="it-stat" style="margin:5px 0 0; font-weight:bold; color: #ff4d4d;">STATS UP</p>
        </div>
    </div>

    <canvas id="gameCanvas" width="900" height="600" class="hidden"></canvas>

    <div class="controls hidden" id="ui-controls">
        <div class="joy-base" id="joy-move"><div class="joy-knob" id="knob-move"></div></div>
        <div class="joy-base" id="joy-shoot"><div class="joy-knob" id="knob-shoot"></div></div>
    </div>

    <script>
        // --- ÁUDIO PROCEDURAL (Sintetizador Web Audio API) ---
        let audioCtx;
        function initAudio() {
            if(audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Drone de fundo (Frequência baixa e sombria)
            const drone = audioCtx.createOscillator();
            const droneGain = audioCtx.createGain();
            drone.type = 'triangle';
            drone.frequency.value = 65.41; // Nota C2
            droneGain.gain.value = 0.05;
            drone.connect(droneGain); droneGain.connect(audioCtx.destination);
            drone.start();

            // Arpejo Aleatório Assustador
            setInterval(() => {
                if(game.active) {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sine';
                    const notes = [130.81, 155.56, 196.00, 233.08]; // C3, Eb3, G3, Bb3 (Acorde Menor 7)
                    osc.frequency.value = notes[Math.floor(Math.random()*notes.length)];
                    
                    gain.gain.setValueAtTime(0.0, audioCtx.currentTime);
                    gain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);
                    
                    osc.connect(gain); gain.connect(audioCtx.destination);
                    osc.start(); osc.stop(audioCtx.currentTime + 1.5);
                }
            }, 800);
        }

        function playSoundHit() {
            if(!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square'; osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        }

        // --- DADOS DOS PERSONAGENS ---
        const CHARACTERS = [
            { id: 'isaac', name: 'ISAAC', hp: 3, speed: 4.0, dmg: 3.50, fireRate: 25, range: 45, wep: 'tear', color: '#ffccb3', fly: false },
            { id: 'maggy', name: 'MAGGY', hp: 4, speed: 3.0, dmg: 3.50, fireRate: 25, range: 45, wep: 'tear', color: '#ffb3ba', fly: false },
            { id: 'cain', name: 'CAIN', hp: 2, speed: 4.5, dmg: 4.20, fireRate: 25, range: 35, wep: 'tear', color: '#cca28a', fly: false },
            { id: 'judas', name: 'JUDAS', hp: 1, speed: 4.0, dmg: 4.75, fireRate: 25, range: 45, wep: 'tear', color: '#911', fly: false },
            { id: 'eve', name: 'EVE', hp: 2, speed: 4.3, dmg: 2.62, fireRate: 20, range: 45, wep: 'tear', color: '#333', fly: false },
            { id: 'azazel', name: 'AZAZEL', hp: 3, speed: 4.3, dmg: 5.50, fireRate: 35, range: 15, wep: 'laser', color: '#111', fly: true }
        ];
        let currentCharIndex = 0;

        function updateMenuDisplay() {
            const c = CHARACTERS[currentCharIndex];
            document.getElementById('m-name').innerText = c.name;
            document.getElementById('m-avatar').style.background = c.color;
            document.getElementById('m-avatar').style.borderColor = c.id === 'azazel' || c.id === 'judas' || c.id === 'eve' ? '#a22' : '#000';
            document.getElementById('m-hp').innerText = '♥'.repeat(c.hp);
            document.getElementById('m-dmg').innerText = c.dmg.toFixed(2);
            document.getElementById('m-spd').innerText = (c.speed / 4.0).toFixed(2);
            document.getElementById('m-trs').innerText = (30 - c.fireRate).toString();
            document.getElementById('m-rng').innerText = c.range.toString();
        }

        function changeChar(dir) {
            currentCharIndex += dir;
            if (currentCharIndex < 0) currentCharIndex = CHARACTERS.length - 1;
            if (currentCharIndex >= CHARACTERS.length) currentCharIndex = 0;
            updateMenuDisplay();
        }

        window.addEventListener('keydown', e => {
            if (document.getElementById('menu').classList.contains('hidden')) return;
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') changeChar(-1);
            if (e.code === 'ArrowRight' || e.code === 'KeyD') changeChar(1);
            if (e.code === 'Space' || e.code === 'Enter') startGame();
        });
        updateMenuDisplay();

        // --- CORE DO JOGO ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE = 50, GRID_W = 18, GRID_H = 12;

        let player, enemies = [], projectiles = [], enemyProjectiles = [], particles = [], pickups = [];
        let game = { floor: 1, active: false, palette: null, state: 'playing', mapGrid: null, rooms: [], currentRoom: null };
        let itemPool = [];

        const moveIn = { x: 0, y: 0, id: null };
        const shootIn = { x: 0, y: 0, id: null };
        const keys = {};
        
        // Mouse Input
        let mouseAim = { active: false, x: 0, y: 0 };
        canvas.addEventListener('mousedown', e => { mouseAim.active = true; updateMouseAim(e); });
        canvas.addEventListener('mousemove', e => { if(mouseAim.active) updateMouseAim(e); });
        canvas.addEventListener('mouseup', e => { mouseAim.active = false; shootIn.x = 0; shootIn.y = 0; });
        
        function updateMouseAim(e) {
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
            const my = (e.clientY - rect.top) * (canvas.height / rect.height);
            const dx = mx - player.x;
            const dy = my - player.y;
            const dist = Math.hypot(dx, dy) || 1;
            shootIn.x = dx / dist; shootIn.y = dy / dist;
        }

        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        function updateKeyboardInput() {
            if (keys['KeyD'] || keys['KeyA'] || keys['KeyS'] || keys['KeyW']) {
                moveIn.x = keys['KeyD'] ? 1 : (keys['KeyA'] ? -1 : 0);
                moveIn.y = keys['KeyS'] ? 1 : (keys['KeyW'] ? -1 : 0);
            } else if (moveIn.id === null) { moveIn.x = 0; moveIn.y = 0; }

            // Setas sobrepõem o mouse se pressionadas
            if (keys['ArrowRight'] || keys['ArrowLeft'] || keys['ArrowDown'] || keys['ArrowUp']) {
                shootIn.x = keys['ArrowRight'] ? 1 : (keys['ArrowLeft'] ? -1 : 0);
                shootIn.y = keys['ArrowDown'] ? 1 : (keys['ArrowUp'] ? -1 : 0);
                mouseAim.active = false;
            } else if (shootIn.id === null && !mouseAim.active) { shootIn.x = 0; shootIn.y = 0; }
        }

        function setupJoy(baseId, knobId, input) {
            const base = document.getElementById(baseId);
            const knob = document.getElementById(knobId);
            const limit = 40;
            const handle = (t) => {
                const rect = base.getBoundingClientRect();
                const dx = t.clientX - (rect.left + rect.width/2);
                const dy = t.clientY - (rect.top + rect.height/2);
                const d = Math.sqrt(dx*dx + dy*dy) || 1;
                const r = Math.min(d, limit) / d;
                knob.style.transform = `translate(${dx*r}px, ${dy*r}px)`;
                input.x = (dx*r)/limit; input.y = (dy*r)/limit;
            };
            base.addEventListener('touchstart', e => { input.id = e.changedTouches[0].identifier; handle(e.changedTouches[0]); }, {passive:false});
            base.addEventListener('touchmove', e => { for(let t of e.changedTouches) if(t.identifier === input.id) handle(t); }, {passive:false});
            base.addEventListener('touchend', e => {
                for(let t of e.changedTouches) if(t.identifier === input.id) {
                    input.id = null; input.x = 0; input.y = 0; knob.style.transform = `translate(0,0)`;
                }
            }, {passive:false});
        }

        const PALETTES = {
            1: { floor: "#2b2b2b", wall: "#111", rock: "#444", spike: "#888", name: "BASEMENT" },
            3: { floor: "#1a2a3a", wall: "#0a101a", rock: "#2a4a6a", spike: "#68a", name: "CAVES" },
            5: { floor: "#3a1515", wall: "#1a0505", rock: "#5a2525", spike: "#a55", name: "DEPTHS" }
        };

        const ITEMS_DB = [
            { n: "SAD ONION", s: "TEARS UP", f: (p) => p.fireRate = Math.max(5, p.fireRate-6) },
            { n: "PENTAGRAM", s: "DMG UP", f: (p) => p.dmg += 1.0 },
            { n: "MAGIC MUSHROOM", s: "ALL STATS UP", f: (p) => { p.dmg += 0.5; p.speed += 0.5; p.hp++; p.max++; p.tearScale *= 1.2; p.range += 10; p.sizeScale = 1.3; } },
            { n: "THE HALO", s: "ALL STATS UP", f: (p) => { p.dmg += 0.3; p.speed += 0.2; p.hp++; p.max++; p.fireRate -= 2; } },
            { n: "BLOOD OF THE MARTYR", s: "DMG UP", f: (p) => p.dmg += 1.2 },
            { n: "SPOON BENDER", s: "HOMING TEARS", f: (p) => p.homing = true },
            { n: "POLYPHEMUS", s: "MEGA TEARS", f: (p) => { p.dmg += 5.0; p.fireRate += 30; p.tearScale = 2.5; } },
            { n: "NUMBER ONE", s: "TEARS UP", f: (p) => { p.fireRate = Math.max(5, p.fireRate - 12); p.range -= 20; } },
            { n: "20/20", s: "DOUBLE SHOT", f: (p) => p.multiShot = 2 },
            { n: "MUTANT SPIDER", s: "QUAD SHOT", f: (p) => p.multiShot = 4 },
            { n: "BRIMSTONE", s: "BLOOD LASER", f: (p) => { p.wep = 'laser'; p.dmg += 2.0; p.fireRate += 15; p.color = '#211'; p.range = Math.max(p.range, 30); } },
            { n: "CUBE OF MEAT", s: "ORBITAL", f: (p) => p.orbitals.push(new Orbital(p.orbitals.length)) },
            { n: "BREAKFAST", s: "HP UP", f: (p) => { p.max++; p.hp++; } },
            { n: "CUPID'S ARROW", s: "PIERCING TEARS", f: (p) => p.piercing = true },
            { n: "OUIJA BOARD", s: "SPECTRAL TEARS", f: (p) => p.spectral = true },
            { n: "LORD OF THE PIT", s: "FLIGHT", f: (p) => { p.fly = true; p.speed += 0.3; } },
            { n: "MOM'S KNIFE", s: "MELEE COMBAT", f: (p) => { p.wep = 'knife'; p.dmg += 3.0; } },
            { n: "SACRED HEART", s: "HOMING + DMG UP", f: (p) => { p.homing = true; p.dmg *= 2.3; p.tearScale = 1.5; p.fireRate += 10; p.hp++; p.max++; } },
            { n: "SMALL ROCK", s: "DMG UP, SPD DOWN", f: (p) => { p.dmg += 1.0; p.speed -= 0.2; } }
        ];

        // Custom drawing functions for items on pedestal
        function drawItemSprite(ctx, name, x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.lineWidth = 2; ctx.strokeStyle = "#000";
            
            if(name === "SAD ONION") {
                ctx.fillStyle = "#eee"; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = "#5cf"; ctx.fillRect(-5, 0, 2, 6); ctx.fillRect(3, 0, 2, 6); // Lágrimas
            } else if(name === "PENTAGRAM" || name === "BLOOD OF THE MARTYR") {
                ctx.fillStyle = "#a22"; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            } else if(name === "THE HALO") {
                ctx.strokeStyle = "#ff0"; ctx.lineWidth = 3; ctx.beginPath(); ctx.ellipse(0, 0, 12, 4, 0, 0, Math.PI*2); ctx.stroke();
            } else if(name === "BRIMSTONE") {
                ctx.fillStyle = "#111"; ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.strokeStyle = "#a22"; ctx.beginPath(); ctx.moveTo(-5, -8); ctx.lineTo(-10, -15); ctx.stroke();
            } else if(name === "MAGIC MUSHROOM") {
                ctx.fillStyle = "#fff"; ctx.fillRect(-4, 0, 8, 10); ctx.strokeRect(-4, 0, 8, 10);
                ctx.fillStyle = "#f55"; ctx.beginPath(); ctx.arc(0, 0, 10, Math.PI, 0); ctx.fill(); ctx.stroke();
            } else if(name === "MOM'S KNIFE") {
                ctx.fillStyle = "#aaa"; ctx.beginPath(); ctx.moveTo(-8, 8); ctx.lineTo(10, -10); ctx.lineTo(6, 6); ctx.fill(); ctx.stroke();
                ctx.fillStyle = "#632"; ctx.fillRect(-10, 6, 6, 6);
            } else if(name === "SACRED HEART") {
                ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(-4, -2, 6, Math.PI, 0); ctx.arc(4, -2, 6, Math.PI, 0); ctx.lineTo(0, 10); ctx.fill(); ctx.stroke();
            } else {
                // Genérico
                ctx.fillStyle = "#ff0"; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = "#000"; ctx.fillText("?", -4, 4);
            }
            ctx.restore();
        }

        class Orbital {
            constructor(index) { this.angle = index * Math.PI; this.dist = 40; }
            update() { this.angle += 0.05; }
            draw(px, py) {
                let x = px + Math.cos(this.angle)*this.dist, y = py + Math.sin(this.angle)*this.dist;
                ctx.fillStyle = "#822"; ctx.fillRect(x-8, y-8, 16, 16);
                ctx.fillStyle = "#a33"; ctx.fillRect(x-6, y-6, 12, 12);
                ctx.fillStyle = "#fff"; ctx.fillRect(x-2, y-2, 4, 4);
            }
        }

        class Pickup {
            constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.floatY = 0; }
            draw() {
                this.floatY = Math.sin(Date.now()/150)*4;
                if(this.type === 'heart') {
                    ctx.fillStyle = "#f00"; ctx.strokeStyle = "#000"; ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.x-5, this.y+this.floatY, 5, Math.PI, 0); ctx.arc(this.x+5, this.y+this.floatY, 5, Math.PI, 0);
                    ctx.lineTo(this.x, this.y+10+this.floatY); ctx.closePath(); ctx.fill(); ctx.stroke();
                } else if (this.type === 'coin') {
                    ctx.fillStyle = "#ffd700"; ctx.strokeStyle = "#da8"; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(this.x, this.y+this.floatY, 6, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = "#b80"; ctx.fillRect(this.x-1, this.y-3+this.floatY, 2, 6); // Cifrão minimalista
                }
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random() - 0.5) * 8; this.vy = (Math.random() - 0.5) * 8;
                this.life = 20 + Math.random() * 10; this.maxLife = this.life;
            }
            update() { this.x += this.vx; this.y += this.vy; this.vx *= 0.9; this.vy *= 0.9; this.life--; }
            draw() {
                ctx.globalAlpha = this.life / this.maxLife; ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0;
            }
        }

        class Player {
            constructor(c) {
                this.hp = c.hp; this.max = c.hp; this.speed = c.speed; this.dmg = c.dmg; 
                this.fireRate = c.fireRate; this.range = c.range; this.color = c.color; 
                this.wep = c.wep; this.fly = c.fly; this.cd = 0; this.inv = 0; 
                this.multiShot = 1; this.homing = false; this.piercing = false; this.spectral = false;
                this.tearScale = 1.0; this.orbitals = []; this.vx = 0; this.vy = 0;
                this.coins = 0; this.inventory = []; this.sizeScale = 1.0;
            }
            update() {
                if(this.inv > 0) this.inv--;
                updateKeyboardInput();

                this.vx = moveIn.x * this.speed; this.vy = moveIn.y * this.speed;
                let nx = this.x + this.vx; let ny = this.y + this.vy;
                
                // Transição de Sala pelas portas
                if (nx < 40 && game.currentRoom.doors.includes('left') && Math.abs(ny - canvas.height/2) < 40) { transitionRoom('left'); return; }
                if (nx > canvas.width - 40 && game.currentRoom.doors.includes('right') && Math.abs(ny - canvas.height/2) < 40) { transitionRoom('right'); return; }
                if (ny < 40 && game.currentRoom.doors.includes('up') && Math.abs(nx - canvas.width/2) < 40) { transitionRoom('up'); return; }
                if (ny > canvas.height - 40 && game.currentRoom.doors.includes('down') && Math.abs(nx - canvas.width/2) < 40) { transitionRoom('down'); return; }

                if(!isObstacle(nx, this.y, this.fly)) this.x = nx;
                if(!isObstacle(this.x, ny, this.fly)) this.y = ny;

                this.x = Math.max(40, Math.min(canvas.width - 40, this.x));
                this.y = Math.max(40, Math.min(canvas.height - 40, this.y));

                let gx = Math.floor(this.x/TILE), gy = Math.floor(this.y/TILE);
                if(game.currentRoom.map[gy] && game.currentRoom.map[gy][gx] === 3 && !this.fly) this.takeDmg(1);

                this.orbitals.forEach(o => o.update());

                if(this.cd > 0) this.cd--;
                if(Math.hypot(shootIn.x, shootIn.y) > 0.3 && this.cd <= 0 && game.state === 'playing') {
                    this.fire(); this.cd = this.fireRate;
                }
            }
            fire() {
                const a = Math.atan2(shootIn.y, shootIn.x);
                const px = this.vx * 0.4, py = this.vy * 0.4;

                if(this.wep === 'laser' || this.wep === 'knife') return; // Desenhados no frame
                
                let angles = [];
                if (this.multiShot === 1) angles = [a];
                else if (this.multiShot === 2) angles = [a - 0.1, a + 0.1];
                else if (this.multiShot === 3) angles = [a - 0.2, a, a + 0.2];
                else if (this.multiShot === 4) angles = [a - 0.3, a - 0.1, a + 0.1, a + 0.3];
                
                angles.forEach(ang => projectiles.push(new Projectile(this.x, this.y-10, ang, this.dmg, px, py, false, this.homing, this.tearScale, this.range, this.piercing, this.spectral)));
            }
            takeDmg(n) {
                if(this.inv > 0) return;
                this.hp -= n; this.inv = 60;
                playSoundHit();
                for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, "#f00"));
                if(this.hp <= 0) { game.active = false; setTimeout(() => { alert("GAME OVER! Andares: " + game.floor); location.reload(); }, 100); }
            }
            draw() {
                if (this.inv > 0 && Math.floor(Date.now() / 100) % 2 === 0) return; 

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.sizeScale, this.sizeScale);

                // Halo (Atrás do personagem)
                if (this.inventory.includes("THE HALO")) {
                    ctx.strokeStyle = "#ff0"; ctx.lineWidth = 3; ctx.beginPath(); ctx.ellipse(0, -25, 12, 4, 0, 0, Math.PI*2); ctx.stroke();
                }

                ctx.fillStyle = "rgba(0,0,0,0.4)"; ctx.beginPath(); ctx.ellipse(0, 15, 14, 6, 0, 0, Math.PI*2); ctx.fill(); // Sombra

                ctx.fillStyle = this.color; ctx.beginPath(); ctx.ellipse(0, 5, 12, 14, 0, 0, Math.PI*2); ctx.fill();
                ctx.lineWidth = 2; ctx.strokeStyle = "#000"; ctx.stroke(); // Corpo

                let hx = (shootIn.x * 3), hy = -12 + (shootIn.y * 3);
                
                if(this.spectral) { ctx.strokeStyle = "#888"; ctx.globalAlpha = 0.8; }
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(hx, hy, 16, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.globalAlpha = 1.0; ctx.strokeStyle = "#000";

                // Detalhes do Rosto baseados nos itens
                if (this.inventory.includes("SAD ONION")) {
                    ctx.fillStyle = "#5cf"; ctx.fillRect(hx-8, hy+2, 4, 10); ctx.fillRect(hx+4, hy+2, 4, 10);
                }
                if (this.inventory.includes("BRIMSTONE")) {
                    ctx.fillStyle = "#111"; 
                    ctx.beginPath(); ctx.moveTo(hx-10, hy-12); ctx.lineTo(hx-18, hy-20); ctx.lineTo(hx-5, hy-16); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(hx+10, hy-12); ctx.lineTo(hx+18, hy-20); ctx.lineTo(hx+5, hy-16); ctx.fill();
                }

                ctx.fillStyle = "#000";
                let ex = shootIn.x * 4, ey = shootIn.y * 4;
                
                if (this.inventory.includes("POLYPHEMUS")) {
                    ctx.beginPath(); ctx.arc(hx + ex, hy - 2 + ey, 6, 0, Math.PI*2); ctx.fill(); // Um olho gigante
                } else {
                    ctx.beginPath(); ctx.arc(hx - 6 + ex, hy - 2 + ey, 3, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(hx + 6 + ex, hy - 2 + ey, 3, 0, Math.PI*2); ctx.fill();
                }

                // Armas Especiais (Laser / Knife)
                ctx.restore(); // Restaura escala para desenhar as armas com alcance correto
                
                let wHeadX = this.x + hx * this.sizeScale;
                let wHeadY = this.y + hy * this.sizeScale;

                if(this.wep === 'laser' && Math.hypot(shootIn.x, shootIn.y) > 0.5) {
                    ctx.strokeStyle = "rgba(255, 0, 0, 0.8)"; ctx.lineWidth = 25 * this.tearScale; ctx.lineCap = "round";
                    ctx.beginPath(); ctx.moveTo(wHeadX, wHeadY); ctx.lineTo(wHeadX + shootIn.x * (this.range * 15), wHeadY + shootIn.y * (this.range * 15)); ctx.stroke();
                    ctx.strokeStyle = this.homing ? "#a5e" : "#fff"; ctx.lineWidth = 10 * this.tearScale; ctx.stroke();
                    // Hitbox laser inimigo
                    enemies.forEach(e => {
                        let dot = (e.x - this.x)*shootIn.x + (e.y - this.y)*shootIn.y;
                        if(dot > 0 && Math.hypot(e.x - (this.x + shootIn.x*dot), e.y - (this.y + shootIn.y*dot)) < e.size + 15 * this.tearScale) {
                            e.hp -= this.dmg * 0.15; e.hitTimer = 2;
                        }
                    });
                } else if (this.wep === 'knife') {
                    // Mom's knife control: distance changes based on hold time
                    let kDist = 20;
                    if(Math.hypot(shootIn.x, shootIn.y) > 0.5) kDist = 60; // Simplificado: faca avança se atirando
                    let kx = wHeadX + shootIn.x * kDist;
                    let ky = wHeadY + shootIn.y * kDist;
                    
                    ctx.save(); ctx.translate(kx, ky); ctx.rotate(Math.atan2(shootIn.y, shootIn.x) + Math.PI/4);
                    ctx.fillStyle = "#aaa"; ctx.strokeStyle = "#000"; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(20, -20); ctx.lineTo(5, 5); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = "#632"; ctx.fillRect(-8, -8, 10, 10); ctx.strokeRect(-8, -8, 10, 10);
                    ctx.restore();
                    
                    // Hitbox knife
                    enemies.forEach(e => { if(Math.hypot(kx-e.x, ky-e.y) < e.size + 10) { e.hp -= this.dmg * 0.2; e.hitTimer = 2; }});
                }

                this.orbitals.forEach(o => o.draw(this.x, this.y));
            }
        }

        class Projectile {
            constructor(x, y, a, d, px, py, isEnemy, homing = false, scale = 1.0, range = 45, piercing = false, spectral = false) { 
                this.x = x; this.y = y; 
                this.vx = Math.cos(a)* (isEnemy ? 6 : 10) + px; 
                this.vy = Math.sin(a)* (isEnemy ? 6 : 10) + py; 
                this.dmg = d; this.life = range; 
                this.isEnemy = isEnemy; this.homing = homing; this.scale = scale;
                this.piercing = piercing; this.spectral = spectral;
            }
            update() { 
                if(this.homing && !this.isEnemy && enemies.length > 0) {
                    let target = null, minDist = 250;
                    enemies.forEach(e => {
                        let d = Math.hypot(this.x-e.x, this.y-e.y);
                        if(d < minDist) { minDist = d; target = e; }
                    });
                    if(target) {
                        let a = Math.atan2(target.y-this.y, target.x-this.x);
                        this.vx += Math.cos(a)*1.5; this.vy += Math.sin(a)*1.5;
                        let s = Math.hypot(this.vx, this.vy);
                        this.vx = (this.vx/s)*10; this.vy = (this.vy/s)*10;
                    }
                }

                this.x += this.vx; this.y += this.vy; this.life--; 
                if(this.x < 50 || this.x > canvas.width-50 || this.y < 50 || this.y > canvas.height-50) this.life = 0;
                if(!this.spectral && isObstacle(this.x, this.y, false)) this.life = 0;
            }
            draw() { 
                ctx.fillStyle = this.isEnemy ? "#ff4d4d" : (this.homing ? "#c7f" : (this.spectral ? "#eee" : "#a8d8ff")); 
                ctx.strokeStyle = this.isEnemy ? "#a00" : (this.homing ? "#62a" : (this.spectral ? "#ccc" : "#4488cc")); 
                ctx.lineWidth = 2;
                if(this.spectral && !this.isEnemy) ctx.globalAlpha = 0.6;
                ctx.beginPath(); ctx.arc(this.x, this.y, 8 * this.scale, 0, Math.PI*2); ctx.fill(); ctx.stroke(); 
                ctx.globalAlpha = 1.0;
                
                ctx.fillStyle = "rgba(255,255,255,0.6)";
                ctx.beginPath(); ctx.arc(this.x-2, this.y-2, 3 * this.scale, 0, Math.PI*2); ctx.fill();
            }
            destroy() {
                let color = this.isEnemy ? "#ff4d4d" : (this.homing ? "#c7f" : "#a8d8ff");
                for(let i=0; i<4; i++) particles.push(new Particle(this.x, this.y, color));
            }
        }

        class Enemy {
            constructor(x, y, type) { 
                this.x = x; this.y = y; this.type = type;
                this.hitTimer = 0; this.vx = 0; this.vy = 0;
                this.attackCooldown = Math.random() * 60;

                let scaleHP = game.floor * 2;
                let scaleSpd = game.floor * 0.1;

                switch(type) {
                    case 'gaper': this.hp = 5 + scaleHP; this.size = 18; this.speed = 1.5 + scaleSpd; this.color = "#563"; this.fly = false; break;
                    case 'pooter': this.hp = 3 + scaleHP; this.size = 14; this.speed = 1.0 + scaleSpd; this.color = "#222"; this.fly = true; break;
                    case 'clotty': this.hp = 8 + scaleHP; this.size = 22; this.speed = 0.8 + scaleSpd; this.color = "#a22"; this.fly = false; break;
                    case 'boss': this.hp = 50 + (game.floor * 30); this.size = 35; this.speed = 1.5 + scaleSpd; this.color = "#822"; this.fly = false; break;
                }
                this.maxHp = this.hp;
            }
            update() {
                if (this.hitTimer > 0) this.hitTimer--;
                let dx = player.x - this.x, dy = player.y - this.y;
                let dist = Math.hypot(dx, dy) || 1;

                if (this.type === 'gaper' || this.type === 'boss') {
                    this.vx = (dx/dist) * this.speed; this.vy = (dy/dist) * this.speed;
                } else if (this.type === 'clotty') {
                    if (dist > 150) { this.vx = (dx/dist) * this.speed; this.vy = (dy/dist) * this.speed; } else { this.vx = 0; this.vy = 0; }
                } else if (this.type === 'pooter') {
                    if (dist > 200) { this.vx = (dx/dist) * this.speed; this.vy = (dy/dist) * this.speed; }
                    else if (dist < 100) { this.vx = -(dx/dist) * this.speed; this.vy = -(dy/dist) * this.speed; }
                    else { this.vx = 0; this.vy = 0; }
                }

                let nx = this.x + this.vx; let ny = this.y + this.vy;
                if(!isObstacle(nx, this.y, this.fly)) this.x = nx;
                if(!isObstacle(this.x, ny, this.fly)) this.y = ny;

                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.attackCooldown <= 0) {
                    if (this.type === 'pooter' && dist < 300) {
                        enemyProjectiles.push(new Projectile(this.x, this.y, Math.atan2(dy, dx), 1, 0, 0, true));
                        this.attackCooldown = 90;
                    } 
                    else if (this.type === 'clotty') {
                        enemyProjectiles.push(new Projectile(this.x, this.y, 0, 1, 0, 0, true));
                        enemyProjectiles.push(new Projectile(this.x, this.y, Math.PI/2, 1, 0, 0, true));
                        enemyProjectiles.push(new Projectile(this.x, this.y, Math.PI, 1, 0, 0, true));
                        enemyProjectiles.push(new Projectile(this.x, this.y, -Math.PI/2, 1, 0, 0, true));
                        this.attackCooldown = 120;
                    }
                    else if (this.type === 'boss' && dist < 400) {
                        let ang = Math.atan2(dy, dx);
                        for(let i=-2; i<=2; i++) enemyProjectiles.push(new Projectile(this.x, this.y, ang + (i*0.2), 1, 0, 0, true));
                        this.attackCooldown = 100;
                    }
                }
            }
            draw() {
                ctx.save();
                ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.beginPath(); ctx.ellipse(this.x, this.y+this.size-2, this.size, this.size/2, 0, 0, Math.PI*2); ctx.fill();

                ctx.fillStyle = this.hitTimer > 0 ? "#fff" : this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                
                ctx.fillStyle = "#000";
                if (this.type === 'boss') {
                    ctx.beginPath(); ctx.arc(this.x-10, this.y-5, 6, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(this.x+10, this.y-5, 6, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(this.x, this.y+10, 12, 0, Math.PI); ctx.fill();
                } else {
                    ctx.beginPath(); ctx.arc(this.x-this.size/2.5, this.y-2, 3, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(this.x+this.size/2.5, this.y-2, 3, 0, Math.PI*2); ctx.fill();
                }

                if (this.type === 'boss') {
                    ctx.fillStyle = "#000"; ctx.fillRect(canvas.width/2 - 100, 20, 200, 15);
                    ctx.fillStyle = "#a00"; ctx.fillRect(canvas.width/2 - 100, 20, 200 * (this.hp/this.maxHp), 15);
                    ctx.strokeStyle = "#444"; ctx.strokeRect(canvas.width/2 - 100, 20, 200, 15);
                }
                ctx.restore();
            }
        }

        // --- GERAÇÃO DE MAPA E SALAS ---
        function generateFloorMap() {
            let numRooms = 5 + Math.floor(game.floor * 1.5);
            let grid = Array(9).fill(null).map(() => Array(9).fill(null));
            let roomsList = [];
            
            grid[4][4] = { type: 'spawn', cleared: true, x: 4, y: 4, doors: [], map: buildRoomMap('spawn'), item: null, discovered: true };
            roomsList.push(grid[4][4]);
            
            let attempts = 0;
            while(roomsList.length < numRooms && attempts < 1000) {
                let r = roomsList[Math.floor(Math.random() * roomsList.length)];
                let dirs = [[0,-1, 'up'], [0,1, 'down'], [-1,0, 'left'], [1,0, 'right']];
                let d = dirs[Math.floor(Math.random() * dirs.length)];
                let nx = r.x + d[0], ny = r.y + d[1];
                
                if(nx >= 0 && nx < 9 && ny >= 0 && ny < 9 && !grid[ny][nx]) {
                    grid[ny][nx] = { type: 'normal', cleared: false, x: nx, y: ny, doors: [], map: buildRoomMap('normal'), item: null, discovered: false };
                    roomsList.push(grid[ny][nx]);
                }
                attempts++;
            }
            
            roomsList.sort((a,b) => Math.hypot(b.x-4, b.y-4) - Math.hypot(a.x-4, a.y-4));
            roomsList[0].type = 'boss';
            
            let itemRoom = roomsList.find(r => r.type === 'normal' && r !== roomsList[0]);
            if(itemRoom) {
                itemRoom.type = 'item'; 
                if(itemPool.length > 0) {
                    let idx = Math.floor(Math.random()*itemPool.length);
                    itemRoom.item = itemPool.splice(idx, 1)[0];
                }
                itemRoom.map = buildRoomMap('empty');
            }

            let shopRoom = roomsList.find(r => r.type === 'normal' && r !== roomsList[0] && r.type !== 'item');
            if(shopRoom) {
                shopRoom.type = 'shop';
                shopRoom.cleared = true;
                if(itemPool.length > 0) {
                    let idx = Math.floor(Math.random()*itemPool.length);
                    shopRoom.item = itemPool.splice(idx, 1)[0];
                }
                shopRoom.map = buildRoomMap('empty');
            }

            if(itemPool.length > 0) {
                let idx = Math.floor(Math.random()*itemPool.length);
                roomsList[0].item = itemPool.splice(idx, 1)[0];
            }
            roomsList[0].map = buildRoomMap('empty');

            roomsList.forEach(r => {
                if(grid[r.y-1] && grid[r.y-1][r.x]) r.doors.push('up');
                if(grid[r.y+1] && grid[r.y+1][r.x]) r.doors.push('down');
                if(grid[r.y][r.x-1]) r.doors.push('left');
                if(grid[r.y][r.x+1]) r.doors.push('right');
            });
            
            game.mapGrid = grid; game.rooms = roomsList;
            loadRoom(4, 4);
        }

        function buildRoomMap(type) {
            let m = Array.from({length: GRID_H}, () => Array(GRID_W).fill(0));
            if (type === 'empty' || type === 'spawn') return m;
            
            for(let y=1; y<GRID_H-1; y++) {
                for(let x=1; x<GRID_W-1; x++) {
                    // Garantir caminhos livres (Cruz de portas)
                    if ((x >= 7 && x <= 10) || (y >= 4 && y <= 7)) continue;
                    
                    let r = Math.random();
                    if(r < 0.10) m[y][x] = 1; // Rocha
                    else if(r < 0.12) m[y][x] = 3; // Espinho
                }
            }
            return m;
        }

        function loadRoom(gx, gy) {
            game.currentRoom = game.mapGrid[gy][gx];
            game.currentRoom.discovered = true;
            enemies = []; projectiles = []; enemyProjectiles = []; particles = []; pickups = []; upgrade = null;
            
            if (!game.currentRoom.cleared) {
                if (game.currentRoom.type === 'normal') {
                    let numE = 2 + Math.floor(game.floor);
                    for(let i=0; i<numE; i++) {
                        let r = Math.random(), type = 'gaper';
                        if (game.floor > 1 && r > 0.4) type = 'pooter';
                        if (game.floor > 2 && r > 0.7) type = 'clotty';
                        enemies.push(new Enemy(Math.random()*(canvas.width-150)+75, Math.random()*(canvas.height-150)+75, type));
                    }
                } else if (game.currentRoom.type === 'boss') {
                    enemies.push(new Enemy(canvas.width/2, canvas.height/2, 'boss'));
                }
            } else {
                checkRoomClearRewards();
            }
        }

        function transitionRoom(dir) {
            let nx = game.currentRoom.x, ny = game.currentRoom.y;
            if (dir === 'up') { ny--; player.y = canvas.height - 60; }
            if (dir === 'down') { ny++; player.y = 60; }
            if (dir === 'left') { nx--; player.x = canvas.width - 60; }
            if (dir === 'right') { nx++; player.x = 60; }
            loadRoom(nx, ny);
        }

        function isObstacle(x, y, isFlying) {
            let gx = Math.floor(x/TILE), gy = Math.floor(y/TILE);
            if(gx <= 0 || gx >= GRID_W-1 || gy <= 0 || gy >= GRID_H-1) {
                let inDoorZone = false;
                if (gx <= 0 && game.currentRoom.doors.includes('left') && Math.abs(y - canvas.height/2) < 40) inDoorZone = true;
                if (gx >= GRID_W-1 && game.currentRoom.doors.includes('right') && Math.abs(y - canvas.height/2) < 40) inDoorZone = true;
                if (gy <= 0 && game.currentRoom.doors.includes('up') && Math.abs(x - canvas.width/2) < 40) inDoorZone = true;
                if (gy >= GRID_H-1 && game.currentRoom.doors.includes('down') && Math.abs(x - canvas.width/2) < 40) inDoorZone = true;
                return !inDoorZone;
            }
            if (game.currentRoom.map[gy] && game.currentRoom.map[gy][gx] === 1) return !isFlying;
            return false;
        }

        function checkRoomClearRewards() {
            if (game.currentRoom.type === 'item' && game.currentRoom.item) {
                upgrade = { x: canvas.width/2, y: canvas.height/2, item: game.currentRoom.item, floatY: 0, price: 0 };
            } else if (game.currentRoom.type === 'shop' && game.currentRoom.item) {
                upgrade = { x: canvas.width/2, y: canvas.height/2, item: game.currentRoom.item, floatY: 0, price: 15 };
            } else if (game.currentRoom.type === 'boss') {
                if (game.currentRoom.item) upgrade = { x: canvas.width/2, y: canvas.height/2 - 50, item: game.currentRoom.item, floatY: 0, price: 0 };
                game.currentRoom.trapdoor = true;
            }
        }

        function drawHUD() {
            for(let i=0; i<player.max; i++) {
                ctx.fillStyle = i < player.hp ? "#f00" : "#333";
                ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
                let hx = 20 + i*25, hy = 20;
                ctx.beginPath();
                ctx.arc(hx-5, hy, 6, Math.PI, 0); ctx.arc(hx+5, hy, 6, Math.PI, 0);
                ctx.lineTo(hx, hy+10); ctx.closePath(); ctx.fill(); ctx.stroke();
            }

            ctx.fillStyle = "rgba(255,255,255,0.7)"; ctx.font = "bold 14px monospace";
            ctx.fillText("FLOOR: " + game.floor, 20, 55);
            ctx.fillText("DMG: " + player.dmg.toFixed(2), 20, 75);
            ctx.fillText("SPD: " + (player.speed / 4.0).toFixed(2), 20, 95);
            
            ctx.fillStyle = "#ffd700";
            ctx.fillText("COINS: " + player.coins, 20, 115);

            ctx.save();
            ctx.translate(canvas.width - 120, 20);
            ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(0, 0, 100, 100);
            
            game.rooms.forEach(r => {
                if(!r.discovered) return;
                let mx = (r.x - 4) * 12 + 45, my = (r.y - 4) * 12 + 45;
                ctx.fillStyle = (r === game.currentRoom) ? "#fff" : (r.cleared ? "#888" : "#555");
                if (r.type === 'boss') ctx.fillStyle = (r === game.currentRoom) ? "#fff" : "#a22";
                if (r.type === 'item') ctx.fillStyle = (r === game.currentRoom) ? "#fff" : "#dd2";
                if (r.type === 'shop') ctx.fillStyle = (r === game.currentRoom) ? "#fff" : "#2d2";
                
                ctx.fillRect(mx, my, 10, 10);
                
                ctx.fillStyle = "#222";
                if(r.doors.includes('up')) ctx.fillRect(mx+4, my-2, 2, 2);
                if(r.doors.includes('down')) ctx.fillRect(mx+4, my+10, 2, 2);
                if(r.doors.includes('left')) ctx.fillRect(mx-2, my+4, 2, 2);
                if(r.doors.includes('right')) ctx.fillRect(mx+10, my+4, 2, 2);
            });
            ctx.restore();
        }

        function startGame() {
            initAudio(); // Inicia trilha sonora
            itemPool = [...ITEMS_DB]; // Preenche o pool
            document.getElementById('menu').classList.add('hidden');
            ['ui-layer', 'gameCanvas', 'ui-controls'].forEach(id => document.getElementById(id).classList.remove('hidden'));

            const c = CHARACTERS[currentCharIndex];
            player = new Player(c);
            player.x = canvas.width/2; player.y = canvas.height/2;
            
            game.active = true; game.floor = 1;
            
            setupJoy('joy-move', 'knob-move', moveIn);
            setupJoy('joy-shoot', 'knob-shoot', shootIn);
            newFloor(); loop();
        }

        function newFloor() {
            let pKey = Object.keys(PALETTES).reverse().find(k => game.floor >= k) || 1;
            game.palette = PALETTES[pKey];
            generateFloorMap();
        }

        function loop() {
            if(!game.active) return;
            
            ctx.fillStyle = game.palette.wall; ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle = game.palette.floor; ctx.fillRect(TILE, TILE, canvas.width - TILE*2, canvas.height - TILE*2);
            ctx.fillStyle = "rgba(0,0,0,0.4)"; ctx.fillRect(TILE, TILE, canvas.width - TILE*2, 10);
            
            ctx.fillStyle = enemies.length > 0 ? "#522" : "#222";
            if (game.currentRoom.doors.includes('up')) ctx.fillRect(canvas.width/2 - 30, 0, 60, TILE);
            if (game.currentRoom.doors.includes('down')) ctx.fillRect(canvas.width/2 - 30, canvas.height - TILE, 60, TILE);
            if (game.currentRoom.doors.includes('left')) ctx.fillRect(0, canvas.height/2 - 30, TILE, 60);
            if (game.currentRoom.doors.includes('right')) ctx.fillRect(canvas.width - TILE, canvas.height/2 - 30, TILE, 60);

            for(let y=1; y<GRID_H-1; y++) for(let x=1; x<GRID_W-1; x++) {
                let xp = x*TILE, yp = y*TILE;
                if(game.currentRoom.map[y][x] === 1) { 
                    ctx.fillStyle = game.palette.rock; ctx.fillRect(xp + 2, yp + 2, TILE-4, TILE-4);
                    ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.fillRect(xp + 2, yp + 40, TILE-4, 8);
                } else if (game.currentRoom.map[y][x] === 3) { 
                    ctx.fillStyle = "#333"; ctx.fillRect(xp+5, yp+5, TILE-10, TILE-10);
                    ctx.fillStyle = game.palette.spike;
                    ctx.beginPath(); ctx.moveTo(xp+10,yp+40); ctx.lineTo(xp+25,yp+10); ctx.lineTo(xp+40,yp+40); ctx.fill();
                }
            }

            if(game.currentRoom.trapdoor) {
                let tx = canvas.width/2, ty = canvas.height/2 + 30;
                ctx.fillStyle = "#111"; ctx.fillRect(tx - 25, ty - 25, 50, 50);
                ctx.strokeStyle = "#444"; ctx.lineWidth = 4; ctx.strokeRect(tx - 25, ty - 25, 50, 50);
                ctx.fillStyle = "#333"; ctx.fillRect(tx - 20, ty - 15, 40, 5); ctx.fillRect(tx - 20, ty - 5, 40, 5);
                
                if (Math.hypot(player.x - tx, player.y - ty) < 20) {
                    game.floor++; newFloor(); player.x = canvas.width/2; player.y = canvas.height/2; requestAnimationFrame(loop); return;
                }
            }

            pickups.forEach((p, i) => {
                p.draw();
                if(Math.hypot(player.x - p.x, player.y - p.y) < 20) {
                    if (p.type === 'heart' && player.hp < player.max) { player.hp++; pickups.splice(i, 1); }
                    else if (p.type === 'coin') { player.coins++; pickups.splice(i, 1); }
                }
            });

            if(upgrade) {
                upgrade.floatY = Math.sin(Date.now() / 200) * 5;
                ctx.fillStyle = "#555"; ctx.fillRect(upgrade.x - 15, upgrade.y + 10, 30, 20);
                ctx.fillStyle = "#777"; ctx.fillRect(upgrade.x - 20, upgrade.y + 5, 40, 5);
                
                drawItemSprite(ctx, upgrade.item.n, upgrade.x, upgrade.y - 15 + upgrade.floatY);
                
                if(upgrade.price > 0) {
                    ctx.fillStyle = "#fff"; ctx.font = "bold 14px monospace";
                    ctx.fillText(upgrade.price + "¢", upgrade.x - 10, upgrade.y + 40);
                }

                if(Math.hypot(player.x-upgrade.x, player.y-upgrade.y) < 30) {
                    if (player.coins >= upgrade.price) {
                        player.coins -= upgrade.price;
                        player.inventory.push(upgrade.item.n);
                        upgrade.item.f(player);
                        document.getElementById('it-name').innerText = upgrade.item.n;
                        document.getElementById('it-stat').innerText = upgrade.item.s;
                        const b = document.getElementById('item-banner');
                        b.classList.add('show'); setTimeout(() => b.classList.remove('show'), 2000);
                        game.currentRoom.item = null;
                        upgrade = null; 
                    }
                }
            }

            player.update(); player.draw();

            projectiles.forEach((p, i) => { p.update(); p.draw(); if(p.life <= 0) { p.destroy(); projectiles.splice(i, 1); } });

            enemyProjectiles.forEach((p, i) => {
                p.update(); p.draw();
                if(Math.hypot(p.x - player.x, p.y - player.y) < 15 && player.inv <= 0) { player.takeDmg(1); p.life = 0; }
                if(p.life <= 0) { p.destroy(); enemyProjectiles.splice(i, 1); }
            });

            enemies.forEach((e, i) => {
                let distToDoor = Math.min(player.x, canvas.width - player.x, player.y, canvas.height - player.y);
                if (distToDoor > 60) e.update(); 
                e.draw();
                
                projectiles.forEach((p, pi) => {
                    if(Math.hypot(p.x-e.x, p.y-e.y) < e.size + 8 * p.scale) {
                        e.hp -= p.dmg; e.hitTimer = 5;
                        for(let k=0; k<3; k++) particles.push(new Particle(p.x, p.y, "#f00"));
                        if(!p.piercing) { p.destroy(); projectiles.splice(pi, 1); }
                    }
                });

                if(Math.hypot(e.x-player.x, e.y-player.y) < e.size + 10) player.takeDmg(1);
                
                if(e.hp <= 0) {
                    for(let k=0; k<15; k++) particles.push(new Particle(e.x, e.y, "#900"));
                    let rand = Math.random();
                    if(rand < 0.15) pickups.push(new Pickup(e.x, e.y, 'heart')); 
                    else if (rand < 0.40) pickups.push(new Pickup(e.x, e.y, 'coin'));
                    enemies.splice(i, 1);
                }
            });

            if (enemies.length === 0 && !game.currentRoom.cleared) {
                game.currentRoom.cleared = true;
                checkRoomClearRewards();
            }

            particles.forEach((p, i) => { p.update(); p.draw(); if(p.life <= 0) particles.splice(i, 1); });

            drawHUD();
            requestAnimationFrame(loop);
        }
    </script>
</body>
</html>