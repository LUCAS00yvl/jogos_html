<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Downwell Web - Complete Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root { --theme-color: #E43B44; } /* Vermelho das Cavernas */

        body { margin: 0; overflow: hidden; background: #000; font-family: 'Press Start 2P', monospace; touch-action: none; user-select: none; color: #fff; }
        canvas { display: block; image-rendering: pixelated; }
        
        #ui { position: absolute; top: 10px; left: 0; width: 100%; text-align: center; pointer-events: none; z-index: 10; font-size: 10px; display: none; justify-content: space-around; padding: 0 10px; box-sizing: border-box;}
        .stat { color: #fff; text-shadow: 1px 1px 0 #000; }
        .stat-hp, .stat-gem { color: var(--theme-color); }
        
        #combo-display { position: absolute; right: 20px; top: 40px; color: #fff; font-size: 14px; display: none; z-index: 10; background: var(--theme-color); padding: 5px; border-radius: 2px; border: 2px solid #fff; transition: transform 0.1s;}
        .combo-pulse { transform: scale(1.2) !important; }

        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 30; }
        h1, h2 { color: var(--theme-color); text-align: center; line-height: 1.5; text-shadow: 2px 2px 0 #fff; margin-bottom: 10px;}
        p { font-size: 10px; text-align: center; line-height: 1.5; max-width: 80%; margin-bottom: 20px;}
        
        .btn-menu { background: #000; border: 2px solid #fff; color: #fff; padding: 15px 20px; margin: 10px; font-family: inherit; font-size: 10px; cursor: pointer; transition: 0.1s; width: 80%; max-width: 350px;}
        .btn-menu:hover, .btn-menu:active { background: #fff; color: #000; transform: scale(1.05); }
        .upgrade-desc { font-size: 8px; margin-top: 5px; opacity: 0.8; }

        .controls { position: absolute; bottom: 20px; width: 100%; display: none; justify-content: space-between; padding: 0 20px; box-sizing: border-box; z-index: 20; }
        .btn { width: 60px; height: 60px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.5); border-radius: 5px; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.8); font-size: 20px; }
        .btn:active { background: rgba(255,255,255,0.6); color: #000; border-color: #fff; }
        .d-pad { display: flex; gap: 15px; }

        @media (hover: hover) and (pointer: fine) { .controls { opacity: 0.15; transition: opacity 0.3s;} .controls:hover { opacity: 1; } }
        #flash { position: absolute; top:0; left:0; width:100%; height:100%; background: #fff; opacity: 0; pointer-events: none; z-index: 25; }
    </style>
</head>
<body>
    <div id="flash"></div>

    <div id="start-screen" class="screen">
        <h1>DOWNWELL<br>WEB</h1>
        <p>Selecione seu Estilo para Iniciar:</p>
        <button class="btn-menu" onclick="startGame('normal')">PADRÃO (4 HP)</button>
        <button class="btn-menu" onclick="startGame('boulder')">PEDREGULHO (6 HP)</button>
        <button class="btn-menu" onclick="startGame('float')">FLUTUANTE (3 HP)</button>
    </div>

    <div id="shop-screen" class="screen" style="display: none;">
        <h2 style="color: #fff; text-shadow: none;">ÁREA SEGURA</h2>
        <p>Escolha um aprimoramento:</p>
        <div id="upgrades-container"></div>
    </div>

    <div id="ui">
        <div class="stat stat-hp">HP: <span id="hp">4</span></div>
        <div class="stat">CARGA: <span id="ammo">8</span></div>
        <div class="stat stat-gem">GEMAS: <span id="gems">0</span></div>
        <div class="stat">PROF: <span id="depth">0</span>m</div>
    </div>
    <div id="combo-display"><span id="combo-count">0</span> COMBO</div>

    <div class="controls" id="mobileControls">
        <div class="d-pad">
            <div class="btn" id="left">←</div>
            <div class="btn" id="right">→</div>
        </div>
        <div class="btn" id="action">▲</div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
// --- ÁUDIO PROCEDURAL (Sintetizador Nativo) ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;
let bgmInterval;

const SFX = {
    init: () => { if(!audioCtx) audioCtx = new AudioContext(); },
    playTone: (freq, type, duration, vol=0.1) => {
        if(!audioCtx || audioCtx.state !== 'running') return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + duration);
    },
    shoot: () => SFX.playTone(150, 'square', 0.1, 0.1),
    jump: () => SFX.playTone(300, 'sine', 0.15, 0.05),
    gem: () => SFX.playTone(800, 'square', 0.1, 0.05),
    hit: () => SFX.playTone(100, 'sawtooth', 0.3, 0.2),
    enemyDie: () => SFX.playTone(200, 'sawtooth', 0.2, 0.1),
    startBGM: () => {
        if(bgmInterval) clearInterval(bgmInterval);
        bgmInterval = setInterval(() => {
            if(gameState !== 'playing') return;
            const notes = [110, 110, 220, 110]; // Linha de baixo (Bassline)
            const note = notes[Math.floor(Date.now() / 300) % notes.length];
            SFX.playTone(note, 'square', 0.1, 0.02);
        }, 300);
    }
};

// --- CONFIGURAÇÕES DO JOGO ---
const COLOR_WHITE = '#FFFFFF';
const COLOR_BLACK = '#000000';
const BIOMES = [
    { color: '#E43B44', name: "CAVERNAS" }, // Vermelho
    { color: '#00E4FF', name: "AQUÍFERO" }, // Ciano
    { color: '#8B9BB4', name: "CATACUMBAS" } // Azul Acinzentado
];
let currentBiome = 0;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameState = 'menu'; 
let cameraY = 0;
let maxDepthReached = 0;
let nextShopDepth = 100; 
let shake = 0;
let frames = 0;
let chunkYOffset = 300; 

const WELL_COLS = 10;
const BLOCK_SIZE = 30;
const WELL_WIDTH = WELL_COLS * BLOCK_SIZE; 
let wellLeft, wellRight;

const player = {
    x: 0, y: 0, w: 18, h: 22,
    vx: 0, vy: 0, speed: 6, gravity: 0.6, maxVy: 15, jumpForce: -10,
    hp: 4, maxHp: 4, ammo: 8, maxAmmo: 8, gems: 0, combo: 0,
    grounded: false, weapon: 'machinegun', style: 'normal',
    upgrades: { vampirism: false, piercingBullets: false, chronoBoots: false },
    bullets: [], input: { left: false, right: false }
};

let platforms = []; let enemies = []; let gems = []; let particles = []; let pickups = []; let floatingTexts = [];

// --- CHUNKS DE CENÁRIO ---
const LEVEL_CHUNKS = [
    ["1100000011", "1110000111", "1111001111", "1112002111", "1100E00011"],
    ["1111120011", "1100000011", "1100211111", "110000E011", "1111000011"],
    ["1100000011", "1102222011", "110S00S011", "1101111011", "1100000011"],
    ["1100000011", "1110000111", "1100B00011", "1111221111", "1111001111"],
    ["1100000011", "1000000001", "1000W00001", "100E00E001", "1100000011"]
];

// --- EFEITOS VISUAIS ---
function screenFlash() {
    const flash = document.getElementById('flash');
    flash.style.opacity = '1'; flash.style.transition = 'none';
    setTimeout(() => { flash.style.transition = 'opacity 0.3s'; flash.style.opacity = '0'; }, 50);
}

function spawnFloatingText(x, y, text, color = COLOR_WHITE) {
    floatingTexts.push({x: x, y: y, text: text, color: color, life: 40, vy: -1.5});
}

function createParticles(x, y, count, color) {
    for(let i=0; i<count; i++) particles.push({ x: x, y: y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 15 + Math.random()*15, color: color });
}

// --- INICIALIZAÇÃO E RESIZE ---
function resize() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    wellLeft = (canvas.width / 2) - (WELL_WIDTH / 2); wellRight = wellLeft + WELL_WIDTH;
}
window.addEventListener('resize', resize); resize();

function startGame(style) {
    SFX.init();
    if(audioCtx.state === 'suspended') audioCtx.resume();
    SFX.startBGM();

    player.style = style;
    player.maxHp = style === 'boulder' ? 6 : (style === 'float' ? 3 : 4);
    player.hp = player.maxHp;
    player.gravity = style === 'float' ? 0.4 : 0.6;
    player.maxVy = style === 'float' ? 10 : 15;

    currentBiome = 0;
    document.documentElement.style.setProperty('--theme-color', BIOMES[currentBiome].color);
    
    player.x = canvas.width / 2 - player.w / 2; player.y = 100; player.vy = 0;
    cameraY = 0; maxDepthReached = 0; nextShopDepth = 150; player.gems = 0; player.combo = 0; player.weapon = 'machinegun';
    chunkYOffset = 300;
    platforms = []; enemies = []; gems = []; particles = []; pickups = []; floatingTexts = [];
    
    // CORREÇÃO DO TRAVAMENTO INICIAL: Pré-carregar chunks suficientes para cobrir a tela
    let chunksToPreload = Math.ceil((canvas.height * 2) / (5 * BLOCK_SIZE));
    for (let i = 0; i < chunksToPreload; i++) spawnNextChunk();

    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('ui').style.display = 'flex';
    document.getElementById('mobileControls').style.display = 'flex';
    gameState = 'playing';
    requestAnimationFrame(loop);
}

// --- CONTROLES ---
function handleActionPress() {
    if (gameState !== 'playing') return;
    if (player.grounded) { player.vy = player.jumpForce; player.grounded = false; createParticles(player.x+player.w/2, player.y+player.h, 5, COLOR_WHITE); SFX.jump(); } 
    else { shoot(); }
}

const bind = (id, key) => {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', (e) => { e.preventDefault(); if(id === 'action') handleActionPress(); else player.input[key] = true; });
    el.addEventListener('touchend', (e) => { e.preventDefault(); if(id !== 'action') player.input[key] = false; });
};
bind('left', 'left'); bind('right', 'right'); bind('action', 'action');

window.addEventListener('keydown', (e) => {
    if(e.code === 'ArrowLeft' || e.key === 'a') player.input.left = true;
    if(e.code === 'ArrowRight' || e.key === 'd') player.input.right = true;
    if(e.code === 'Space' || e.code === 'ArrowUp' || e.key === 'w') { if(!e.repeat) handleActionPress(); }
});
window.addEventListener('keyup', (e) => {
    if(e.code === 'ArrowLeft' || e.key === 'a') player.input.left = false;
    if(e.code === 'ArrowRight' || e.key === 'd') player.input.right = false;
});

// --- LÓGICA DO JOGO ---
function shoot() {
    if (player.ammo <= 0) return;
    
    player.vy = player.upgrades.chronoBoots ? -1 : Math.max(player.vy - 5, -3.5); 
    
    if(player.weapon === 'machinegun') {
        player.bullets.push({x: player.x + player.w/2 - 3, y: player.y + player.h, vx: 0, vy: 18, dmg: 1});
        player.ammo--;
    } else if (player.weapon === 'shotgun') {
        if(player.ammo >= 2) {
            player.bullets.push({x: player.x + player.w/2 - 3, y: player.y + player.h, vx: -3.5, vy: 15, dmg: 1});
            player.bullets.push({x: player.x + player.w/2 - 3, y: player.y + player.h, vx: 0, vy: 17, dmg: 1});
            player.bullets.push({x: player.x + player.w/2 - 3, y: player.y + player.h, vx: 3.5, vy: 15, dmg: 1});
            player.ammo -= 2;
        }
    }
    shake = 3; SFX.shoot();
    createParticles(player.x + player.w/2, player.y + player.h, 4, COLOR_WHITE);
    updateUI();
}

function spawnNextChunk() {
    const template = LEVEL_CHUNKS[Math.floor(Math.random() * LEVEL_CHUNKS.length)];
    for (let r = 0; r < template.length; r++) {
        for (let c = 0; c < template[r].length; c++) {
            let char = template[r][c];
            let px = wellLeft + c * BLOCK_SIZE; let py = chunkYOffset + r * BLOCK_SIZE;
            
            if (char === '1') platforms.push({ x: px, y: py, w: BLOCK_SIZE, h: BLOCK_SIZE, type: 'solid', hp: 999 });
            else if (char === '2') platforms.push({ x: px, y: py, w: BLOCK_SIZE, h: BLOCK_SIZE, type: 'breakable', hp: 2 });
            else if (char === 'E') enemies.push({ x: px + 3, y: py + 6, w: 24, h: 24, type: 'basic', hp: 1, dir: 0 });
            else if (char === 'S') enemies.push({ x: px + 3, y: py + 6, w: 24, h: 24, type: 'spiky', hp: 1, dir: 0 });
            else if (char === 'B') enemies.push({ x: px + 3, y: py + 6, w: 24, h: 24, type: 'bat', hp: 1, dir: 1, origX: px+3 });
            else if (char === 'W') pickups.push({ x: px + 5, y: py + 10, w: 20, h: 20, type: 'weapon_shotgun' });
        }
    }
    chunkYOffset += template.length * BLOCK_SIZE;
}

// --- LOJA E PROGRESSÃO ---
const availableUpgrades = [
    { name: 'MAÇÃ SUCULENTA', desc: 'Restaura 2 HP.', action: () => { player.hp = Math.min(player.maxHp, player.hp + 2); } },
    { name: 'CINTURÃO TÁTICO', desc: '+2 Carga Máxima.', action: () => { player.maxAmmo += 2; } },
    { name: 'BOTAS TEMPORAIS', desc: 'Flutuação aprimorada.', action: () => { player.upgrades.chronoBoots = true; } },
    { name: 'PACTO VAMPÍRICO', desc: 'Inimigos podem dropar cura.', action: () => { player.upgrades.vampirism = true; } },
    { name: 'BALAS PERFURANTES', desc: 'Tiros atravessam inimigos.', action: () => { player.upgrades.piercingBullets = true; } }
];

function triggerShop() {
    gameState = 'shop';
    const container = document.getElementById('upgrades-container'); container.innerHTML = '';
    let shuffled = availableUpgrades.sort(() => 0.5 - Math.random()).slice(0, 3);
    shuffled.forEach(upg => {
        let btn = document.createElement('button'); btn.className = 'btn-menu';
        btn.innerHTML = `<strong style="color:var(--theme-color)">${upg.name}</strong><br><div class="upgrade-desc">${upg.desc}</div>`;
        btn.onclick = () => { 
            upg.action(); player.ammo = player.maxAmmo; 
            nextShopDepth += 150; 
            checkBiomeProgress();
            document.getElementById('shop-screen').style.display = 'none'; 
            gameState = 'playing'; updateUI(); 
        };
        container.appendChild(btn);
    });
    document.getElementById('shop-screen').style.display = 'flex';
}

function checkBiomeProgress() {
    // Muda de bioma a cada 2 lojas (aprox. 300m)
    let expectedBiome = Math.floor(maxDepthReached / 300);
    if (expectedBiome > currentBiome && expectedBiome < BIOMES.length) {
        currentBiome = expectedBiome;
        document.documentElement.style.setProperty('--theme-color', BIOMES[currentBiome].color);
        spawnFloatingText(player.x, player.y - 20, BIOMES[currentBiome].name, COLOR_WHITE);
    }
}

function updateUI() {
    document.getElementById('hp').innerText = player.hp;
    document.getElementById('ammo').innerText = player.ammo;
    document.getElementById('gems').innerText = player.gems;
    document.getElementById('depth').innerText = maxDepthReached;
    const comboEl = document.getElementById('combo-display');
    if(player.combo > 0) { comboEl.style.display = 'block'; document.getElementById('combo-count').innerText = player.combo; comboEl.classList.add('combo-pulse'); setTimeout(() => comboEl.classList.remove('combo-pulse'), 100); } 
    else { comboEl.style.display = 'none'; }
}

function update() {
    if (gameState !== 'playing') return;
    frames++;

    // Movimento e Gravidade
    if (player.input.left) player.vx = -player.speed;
    else if (player.input.right) player.vx = player.speed;
    else player.vx *= 0.6; 

    player.vy += player.gravity; 
    if (player.vy > player.maxVy) player.vy = player.maxVy;

    player.x += player.vx; player.y += player.vy;
    let wasGrounded = player.grounded; player.grounded = false;

    // Colisão com Paredes
    if (player.x < wellLeft) { player.x = wellLeft; player.vx = 0; }
    if (player.x > wellRight - player.w) { player.x = wellRight - player.w; player.vx = 0; }

    // Pickups
    for (let i = pickups.length - 1; i >= 0; i--) {
        let p = pickups[i];
        if (player.x < p.x + p.w && player.x + player.w > p.x && player.y < p.y + p.h && player.y + player.h > p.y) {
            if(p.type === 'weapon_shotgun') { player.weapon = 'shotgun'; player.maxAmmo = 6; player.ammo = 6; spawnFloatingText(player.x, player.y, "ESCOPETA"); }
            else if(p.type === 'health') { player.hp = Math.min(player.maxHp, player.hp + 1); spawnFloatingText(player.x, player.y, "+1 HP", BIOMES[currentBiome].color); }
            pickups.splice(i, 1); updateUI(); SFX.gem();
        }
    }

    // Plataformas
    for (let i = platforms.length - 1; i >= 0; i--) {
        let p = platforms[i];
        if (player.x < p.x + p.w && player.x + player.w > p.x && player.y < p.y + p.h && player.y + player.h > p.y) {
            if (player.vy > 0 && player.y + player.h - player.vy <= p.y + 8) { 
                player.vy = 0; player.y = p.y - player.h; player.grounded = true; player.ammo = player.maxAmmo;
                if(!wasGrounded) { if(player.combo >= 5) { player.gems += 20; spawnFloatingText(player.x, player.y-20, "BÔNUS!", COLOR_WHITE); } player.combo = 0; updateUI(); }
            } else if (player.vy < 0 && player.y - player.vy >= p.y + p.h - 8) { 
                player.vy = 0; player.y = p.y + p.h;
                if(p.type === 'breakable') { p.hp--; if(p.hp<=0) { platforms.splice(i, 1); createParticles(p.x+15, p.y+15, 8, COLOR_WHITE); } }
            }
        }
    }

    // Inimigos
    for (let i = enemies.length - 1; i >= 0; i--) {
        let en = enemies[i];
        if(en.type === 'bat') { en.x += en.dir * 2; if (en.x > en.origX + 40) en.dir = -1; else if (en.x < en.origX - 40) en.dir = 1; } 
        else { en.y += Math.sin((frames + i*10) / 15) * 0.5; }

        if (player.x < en.x + en.w && player.x + player.w > en.x && player.y < en.y + en.h && player.y + player.h > en.y) {
            if (player.vy > 0 && player.y + player.h - player.vy <= en.y + en.h/2) {
                if(en.type === 'spiky') { 
                    player.hp--; player.vy = -6; shake = 15; player.combo = 0; screenFlash(); SFX.hit();
                } else { 
                    player.vy = player.jumpForce * 0.8; player.ammo = player.maxAmmo; player.combo++;
                    createParticles(en.x + en.w/2, en.y + en.h/2, 15, BIOMES[currentBiome].color);
                    spawnFloatingText(en.x, en.y, player.combo, COLOR_WHITE);
                    for(let k=0; k<4; k++) gems.push({x: en.x+12, y: en.y+12, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10 - 3});
                    if(player.upgrades.vampirism && Math.random() < 0.1) pickups.push({x: en.x, y: en.y, w: 10, h: 10, type: 'health'});
                    enemies.splice(i, 1); shake = 6; SFX.enemyDie();
                }
            } else { 
                player.hp--; player.vy = -5; shake = 15; player.combo = 0; screenFlash(); SFX.hit(); enemies.splice(i, 1);
            }
            updateUI();
            if(player.hp <= 0) { 
                alert("FIM DE JOGO! Profundidade: " + maxDepthReached + "m"); 
                document.location.reload(); 
                return; // Impede execução extra
            }
        }
    }

    // Tiros
    for (let i = player.bullets.length - 1; i >= 0; i--) {
        let b = player.bullets[i]; b.x += b.vx; b.y += b.vy; let hit = false;
        
        for (let j = enemies.length - 1; j >= 0; j--) {
            let en = enemies[j];
            if (b.x < en.x + en.w && b.x + 6 > en.x && b.y < en.y + en.h && b.y + 16 > en.y) {
                en.hp -= b.dmg;
                if(!player.upgrades.piercingBullets) hit = true;
                if(en.hp <= 0) {
                    createParticles(en.x + en.w/2, en.y + en.h/2, 10, BIOMES[currentBiome].color);
                    for(let k=0; k<2; k++) gems.push({x: en.x+12, y: en.y+12, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8});
                    if(player.upgrades.vampirism && Math.random() < 0.1) pickups.push({x: en.x, y: en.y, w: 10, h: 10, type: 'health'});
                    player.combo++; spawnFloatingText(en.x, en.y, player.combo, COLOR_WHITE); enemies.splice(j, 1); updateUI(); SFX.enemyDie();
                }
                break;
            }
        }
        
        if(!hit) {
            for (let j = platforms.length - 1; j >= 0; j--) {
                let p = platforms[j];
                if (b.x < p.x + p.w && b.x + 6 > p.x && b.y < p.y + p.h && b.y + 16 > p.y) {
                    hit = true;
                    if(p.type === 'breakable') { p.hp -= b.dmg; if(p.hp <= 0) { createParticles(p.x + p.w/2, p.y + p.h/2, 8, COLOR_WHITE); platforms.splice(j, 1); } }
                    createParticles(b.x, b.y + 16, 3, COLOR_WHITE); break;
                }
            }
        }
        if (hit || b.y > cameraY + canvas.height) player.bullets.splice(i, 1);
    }

    // Gemas
    let magnetForce = player.combo > 5 ? 0.15 : 0.05;
    for (let i = gems.length - 1; i >= 0; i--) {
        let g = gems[i]; g.vy += 0.3; g.x += g.vx; g.y += g.vy;
        let dx = player.x + player.w/2 - g.x; let dy = player.y + player.h/2 - g.y;
        if(Math.sqrt(dx*dx + dy*dy) < 80 + (player.combo*5)) { g.vx += dx * magnetForce; g.vy += dy * magnetForce; } 

        if (g.x < player.x + player.w && g.x + 6 > player.x && g.y < player.y + player.h && g.y + 6 > player.y) {
            player.gems++; updateUI(); gems.splice(i, 1); SFX.gem();
        } else if (g.y > cameraY + canvas.height) { gems.splice(i, 1); }
    }

    // Limpeza e Animações de Partículas
    for (let i = floatingTexts.length - 1; i >= 0; i--) { let t = floatingTexts[i]; t.y += t.vy; t.life--; if(t.life <= 0) floatingTexts.splice(i, 1); }
    for (let i = particles.length - 1; i >= 0; i--) { let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life--; if (p.life <= 0) particles.splice(i, 1); }

    // Profundidade e Câmera
    let currentDepth = Math.floor(player.y / 40);
    if (currentDepth > maxDepthReached) {
        maxDepthReached = currentDepth; updateUI();
        if(maxDepthReached >= nextShopDepth) triggerShop();
    }

    let targetCameraY = player.y - canvas.height / 3;
    if (targetCameraY > cameraY) cameraY += (targetCameraY - cameraY) * 0.2;

    // Geração Contínua
    if (platforms.length > 0 && platforms[0].y < cameraY - 100) platforms.shift();
    if (chunkYOffset < cameraY + canvas.height + 300) spawnNextChunk();

    if (shake > 0) shake--;
}

function draw() {
    if (gameState === 'menu') return;

    ctx.save();
    ctx.fillStyle = COLOR_BLACK; ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (shake > 0) ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
    ctx.translate(0, -cameraY);

    ctx.fillStyle = COLOR_WHITE; ctx.fillRect(wellLeft - 8, cameraY, 8, canvas.height + 100); ctx.fillRect(wellRight, cameraY, 8, canvas.height + 100);
    
    let themeColor = BIOMES[currentBiome].color;

    pickups.forEach(p => {
        if(p.type === 'weapon_shotgun') { ctx.fillStyle = COLOR_WHITE; ctx.fillRect(p.x, p.y, p.w, p.h); ctx.fillStyle = COLOR_BLACK; ctx.fillRect(p.x+4, p.y+4, p.w-8, p.h-8); }
        else if(p.type === 'health') { ctx.fillStyle = themeColor; ctx.fillRect(p.x, p.y, p.w, p.h); ctx.fillStyle = COLOR_WHITE; ctx.fillRect(p.x+4, p.y+2, 2, p.h-4); ctx.fillRect(p.x+2, p.y+4, p.w-4, 2); }
    });

    platforms.forEach(p => {
        ctx.fillStyle = COLOR_WHITE; ctx.fillRect(p.x, p.y, p.w, p.h);
        if(p.type === 'solid') { ctx.fillStyle = COLOR_BLACK; ctx.fillRect(p.x + 2, p.y + 2, p.w - 4, p.h - 4); }
        else { ctx.fillStyle = COLOR_BLACK; ctx.fillRect(p.x + 2, p.y + 2, p.w - 4, p.h - 4); ctx.fillStyle = COLOR_WHITE; ctx.fillRect(p.x + 8, p.y + 8, p.w - 16, p.h - 16); } 
    });

    enemies.forEach(en => {
        ctx.fillStyle = themeColor; ctx.fillRect(en.x, en.y, en.w, en.h);
        ctx.fillStyle = COLOR_WHITE; ctx.fillRect(en.x + 4, en.y + 6, 6, 6); ctx.fillRect(en.x + en.w - 10, en.y + 6, 6, 6); 
        ctx.fillStyle = COLOR_BLACK; ctx.fillRect(en.x + 6, en.y + 8, 2, 2); ctx.fillRect(en.x + en.w - 8, en.y + 8, 2, 2); 
        if(en.type === 'spiky') { ctx.fillStyle = COLOR_WHITE; ctx.beginPath(); ctx.moveTo(en.x, en.y); ctx.lineTo(en.x+en.w/2, en.y-8); ctx.lineTo(en.x+en.w, en.y); ctx.fill(); }
        if(en.type === 'bat') { ctx.fillStyle = COLOR_WHITE; ctx.fillRect(en.x - 6, en.y + 4, 6, 4); ctx.fillRect(en.x + en.w, en.y + 4, 6, 4); } 
    });

    ctx.fillStyle = themeColor;
    gems.forEach(g => { ctx.fillRect(g.x, g.y, 6, 6); ctx.fillStyle = COLOR_WHITE; ctx.fillRect(g.x+2, g.y+2, 2, 2); ctx.fillStyle = themeColor; });

    ctx.fillStyle = COLOR_WHITE; player.bullets.forEach(b => ctx.fillRect(b.x, b.y, 6, 16));
    particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life/30; ctx.fillRect(p.x, p.y, 4, 4); ctx.globalAlpha = 1; });

    ctx.font = "10px 'Press Start 2P'"; ctx.textAlign = "center";
    floatingTexts.forEach(t => { ctx.fillStyle = t.color; ctx.globalAlpha = t.life/40; ctx.fillText(t.text, t.x, t.y); ctx.globalAlpha = 1; });

    ctx.fillStyle = COLOR_WHITE; ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.fillStyle = COLOR_BLACK;
    if (player.vx > 0) ctx.fillRect(player.x + 10, player.y + 4, 6, 6);
    else if (player.vx < 0) ctx.fillRect(player.x + 2, player.y + 4, 6, 6);
    else { ctx.fillRect(player.x + 2, player.y + 4, 4, 4); ctx.fillRect(player.x + 12, player.y + 4, 4, 4); }

    ctx.restore();
}

// Inicializa, mas o loop só começa após o clique em startGame
function loop() { 
    if(gameState === 'playing') update(); 
    draw(); 
    requestAnimationFrame(loop); 
}
</script>
</body>
</html>